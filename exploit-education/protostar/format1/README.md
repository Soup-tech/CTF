# Format1

## Understanding Format String Identifiers
If a programmer uses <b>printf(string)</b> rather than <b>printf("%s\n",string)</b> then they are exposed to a format string vulnerability. When printf function is called, the arguments are pushed onto the stack in reverse order. Thus if you call printf with something like:<br>
```C
printf("A is %d and is at %08x. B is %x.\n", A, &A, B); 
```
The stack may look like:
============================
= Address of format string =
============================
= Value of A               =
============================
= Address of A             =
============================
= Value of B               =
============================
= Bottom of the stack      =
============================
But what if only two arguments are pushed onto the stack? The program begins reading values off the stack where it expects the parameter to be. 

## Format String Vulnerability
We can leak stack address/information off the stack using:<br>
```Python
python -c 'print "%x." * 100'
```
Leak far enough and we will see the string itself on the stack. This is because the format function will always be on the highest stack frame. I can also use %s to look for any human readable strings on the stack.

## Writing to Arbitrary Memory Addresses
We can actually write to locations in memory using the %n string identifier. %n will write to a variable however many bytes have been written thus far. So...<br>

```C
int main() {
	int val;
	printf(blah %n blah\n",&val);
	printf(%d\n,val);
	return 0;
}
```
Will make val be equal to 5. 
Thus, all we have to do is put a memory address that we want to write to onto the stack, read up to that memory address, and use %n to write to it.

## Challenge
I solved this problem with this payload:<br>
```bash
./format1 `python -c "print 'AAAA' + '\x38\x96\x04\x08' + 'BBBBB'  + '%x.'*125 + '%n.'"`
```
Some tips and tricks:
1. Keep the 'AAAA', 'BBBB' around the address you are trying to write to. If what your reading is off by 1 or 2 bytes, you can always add/subtract from these paddings
2. Keep the %x that will read the memory address on the stack sepearte from the multiplying '%x.'. This way, once you have it lined up, you can just turn that '%x.' into a '%n.'

Target is at 0x08049638

